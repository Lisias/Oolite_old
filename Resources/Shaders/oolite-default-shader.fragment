/*
	oolite-default-shader.fragment
	Default fragment shader for Oolite ships.
	
	This is similar to normal ship shaders, but has special controlling
	macros (like OOSTD_DIFFUSE_MAP, OOSTD_SPECULAR etc.) which are specific
	to the default shader.
	
	A note on the structure of this file: the GLSL implementation on Mac OS X
	10.4.x can't handle shaders with nested #if/#ifdefs on some systems. I
	haven't explored this in detail, but it seems to be PowerPC-specific.
	Avoiding such nesting while dealing with several controlling macros leads
	to this rather messy code structure.
	This bug is fixed in Mac OS X 10.5.
	
	
	Â© 2007 Jens Ayton

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
	MA 02110-1301, USA.
*/

varying vec3			vNormal;
varying vec3			vEyeVector;


#ifndef OOSTD_DIFFUSE_MAP
#define OOSTD_DIFFUSE_MAP 0
#endif

#ifndef OOSTD_SPECULAR
#define OOSTD_SPECULAR 0
#undef OOSTD_SPECULAR_MAP
#endif

#ifndef OOSTD_SPECULAR_MAP
#define OOSTD_SPECULAR_MAP 0
#endif

#ifndef OOSTD_EMISSION
#define OOSTD_EMISSION 0
#endif

#ifndef OOSTD_EMISSION_MAP
#define OOSTD_EMISSION_MAP 0
#endif

#ifndef OOSTD_ILLUMINATION_MAP
#define OOSTD_ILLUMINATION_MAP 0
#endif

#ifndef OOSTD_EMISSION_AND_ILLUMINATION_MAP
#define OOSTD_EMISSION_AND_ILLUMINATION_MAP 0
#endif

#ifndef OO_LIGHT_0_FIX
#define OO_LIGHT_0_FIX 0
#endif


#if OOSTD_EMISSION_AND_ILLUMINATION_MAP && ! OOSTD_EMISSION_MAP
#undef OOSTD_EMISSION_MAP
#define OOSTD_EMISSION_MAP 1
#endif
#if OOSTD_EMISSION_AND_ILLUMINATION_MAP && OOSTD_ILLUMINATION_MAP
#undef OOSTD_EMISSION_AND_ILLUMINATION_MAP
#define OOSTD_EMISSION_AND_ILLUMINATION_MAP 0
#endif


#ifdef OOSTD_DIFFUSE_MAP
uniform sampler2D		uDiffuseMap;
#endif

#ifdef OOSTD_SPECULAR_MAP
uniform sampler2D		uSpecularMap;
#endif

#ifdef OOSTD_EMISSION_MAP
uniform sampler2D		uEmissionMap;
#endif

#ifdef OOSTD_ILLUMINATION_MAP
uniform sampler2D		uIlluminationMap;
#endif


#if OOSTD_DIFFUSE_MAP || OOSTD_SPECULAR_MAP || OOSTD_EMISSION_MAP || OOSTD_ILLUMINATION_MAP
#define NEED_TEX_COORD
#endif

#if OOSTD_EMISSION_AND_ILLUMINATION_MAP || OOSTD_ILLUMINATION_MAP
#define HAVE_ILLUMINATION
#endif


// Lambertian diffuse lighting model
#define DIFFUSE_LIGHT(idx) \
	{ \
		vec3 lightVector = normalize(gl_LightSource[idx].position.xyz); \
		float intensity = max(dot(normal, lightVector), 0.0); \
		diffuseLight += gl_LightSource[idx].diffuse * intensity; \
	}



#if OOSTD_SPECULAR
#define SPECULAR_LIGHT(idx) \
	{ \
		vec3 lightVector = normalize(gl_LightSource[idx].position.xyz); \
		vec3 reflection = normalize(-reflect(lightVector, normal)); \
		float intensity = pow(max(dot(reflection, eyeVector), 0.0), exponent); \
		specularLight += gl_LightSource[idx].specular * intensity; \
	}
#endif

#if OOSTD_SPECULAR
#define NEED_EYE_VECTOR
#endif

#if OOSTD_SPECULAR && OO_LIGHT_0_FIX
#define SPECULAR_LIGHT_0 SPECULAR_LIGHT(0)
#else
#define SPECULAR_LIGHT_0
#endif


#ifndef OO_REDUCED_COMPLEXITY
uniform float			uHullHeatLevel;
uniform float			uTime;


// Irregular flickering function.
float Pulse(float value, float timeScale)
{
	float t = uTime * timeScale;   
	
	float s0 = t;
	s0 -= floor(s0);
	float sum = abs( s0 - 0.5);
	
	float s1 = t * 0.7 - 0.05;
	s1 -= floor(s1);
	sum += abs(s1 - 0.5) - 0.25;
	
	float s2 = t * 1.3 - 0.3;
	s2 -= floor(s2);
	sum += abs(s2 - 0.5) - 0.25;
	
	float s3 = t * 5.09 - 0.6;
	s3 -= floor(s3);
	sum += abs(s3 - 0.5) - 0.25;
	
	return (sum * 0.1 + 0.9) * value;
}


// Colour ramp from black through reddish brown/dark orange to yellow-white.
vec4 TemperatureGlow(float level)
{
	vec4 result = vec4(0);
	
	result.r = level;
	result.g = level * level * level;
	result.b = max(level - 0.7, 0.0) * 2.0;
	result.a = 1.0;
	
	return result;	
}
#endif


void main(void)
{
	vec4 totalColor = vec4(0);
	vec3 normal = normalize(vNormal);
#ifdef NEED_EYE_VECTOR
	vec3 eyeVector = normalize(vEyeVector);
#endif
#ifdef NEED_TEX_COORD
	vec2 texCoord = gl_TexCoord[0].st;
#endif
	
	vec4 ambientLight = gl_FrontMaterial.ambient * gl_LightModel.ambient;
	
#if OOSTD_EMISSION || OOSTD_EMISSION_MAP
	vec4 emissionColor = vec4(1.0);
#endif
#if OOSTD_EMISSION
	emissionColor *= gl_FrontMaterial.emission;
#endif
#if OOSTD_EMISSION_MAP
	vec4 emissionMapColor = texture2D(uEmissionMap, texCoord);
	emissionColor *= emissionMapColor;
#endif
#if OOSTD_EMISSION || OOSTD_EMISSION_MAP
	emissionColor.a = 1.0;
	totalColor += emissionColor;
#endif
#if OOSTD_EMISSION_AND_ILLUMINATION_MAP
	// Use alpha channel of emission map as white illumination
	vec4 illuminationMapLight = vec4(emissionMapColor.aaa, 1.0);
#elif OOSTD_ILLUMINATION_MAP
	vec4 illuminationMapLight = texture2D(uIlluminationMap, texCoord);
#endif
	
	vec4 diffuseLight = vec4(0);
#if OO_LIGHT_0_FIX
	DIFFUSE_LIGHT(0)
#endif
	DIFFUSE_LIGHT(1)
	
#ifdef HAVE_ILLUMINATION
	diffuseLight += illuminationMapLight;
#endif
	
#if OOSTD_SPECULAR_MAP
	vec4 specularMapColor = texture2D(uSpecularMap, texCoord);
	float specularExponentLevel = pow(specularMapColor.a, 2.0) + 0.001;
	specularMapColor.a = 1.0;
	#define APPLY_MAPPED_EXPONENT exponent = (exponent - 1.0) * specularExponentLevel + 1.0;
#else
	#define APPLY_MAPPED_EXPONENT
#endif
#if OOSTD_SPECULAR
	vec4 specularLight = vec4(0);
	float exponent = gl_FrontMaterial.shininess;
	APPLY_MAPPED_EXPONENT
	SPECULAR_LIGHT_0
	SPECULAR_LIGHT(1)
	specularLight.a = 1.0;
#endif
	
	vec4 ambientColor = gl_FrontMaterial.ambient;
	vec4 diffuseColor = gl_FrontMaterial.diffuse;
#if OOSTD_SPECULAR
	vec4 specularColor = gl_FrontMaterial.specular;
#endif
#if OOSTD_SPECULAR_MAP
	specularColor *= specularMapColor;
#endif
	
#if OOSTD_DIFFUSE_MAP
	vec4 diffuseMapColor = texture2D(uDiffuseMap, texCoord);
	diffuseMapColor.a = 1.0;
	diffuseColor *= diffuseMapColor;
	ambientColor *= diffuseMapColor;
#endif
	
	totalColor += ambientColor * ambientLight + diffuseColor * diffuseLight;
#if OOSTD_SPECULAR
	totalColor += specularColor * specularLight;
#endif
	
#ifndef OO_REDUCED_COMPLEXITY
	// Heat glow
	float hullHeat = max(uHullHeatLevel - 0.5, 0.0) * 2.0;
	hullHeat = Pulse(hullHeat * hullHeat, 0.1);
	totalColor += TemperatureGlow(hullHeat);
#endif
	
	gl_FragColor = totalColor;
}
