/*
	oolite-default-shader.fragment
	Default fragment shader for Oolite ships.
	
	This is similar to normal ship shaders, but has special controlling
	macros (like OOSTD_DIFFUSE_MAP, OOSTD_SPECULAR etc.) which are specific
	to the default shader.
	
	
	?©2007 Jens Ayton

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
	MA 02110-1301, USA.
*/

varying vec3			vNormal;
varying vec3			vEyeVector;


#ifndef OOSTD_DIFFUSE_MAP
#define OOSTD_DIFFUSE_MAP 0
#endif

#ifndef OOSTD_SPECULAR
#define OOSTD_SPECULAR 0
#undef OOSTD_SPECULAR_MAP
#endif

#ifndef OOSTD_SPECULAR_MAP
#define OOSTD_SPECULAR_MAP 0
#endif

#ifndef OOSTD_EMISSION
#define OOSTD_EMISSION 0
#endif

#ifndef OOSTD_EMISSION_MAP
#define OOSTD_EMISSION_MAP 0
#endif

#ifndef OOSTD_ILLUMINATION_MAP
#define OOSTD_ILLUMINATION_MAP 0
#endif

#ifndef OOSTD_EMISSION_AND_ILLUMINATION_MAP
#define OOSTD_EMISSION_AND_ILLUMINATION_MAP 0
#endif

#ifndef OO_LIGHT_0_FIX
#define OO_LIGHT_0_FIX 0
#endif


#if OOSTD_EMISSION_AND_ILLUMINATION_MAP && ! OOSTD_EMISSION_MAP
#undef OOSTD_EMISSION_MAP
#define OOSTD_EMISSION_MAP 1
#endif
#if OOSTD_EMISSION_AND_ILLUMINATION_MAP && OOSTD_ILLUMINATION_MAP
#undef OOSTD_EMISSION_AND_ILLUMINATION_MAP
#define OOSTD_EMISSION_AND_ILLUMINATION_MAP 0
#endif


#ifdef OOSTD_DIFFUSE_MAP
uniform sampler2D		uDiffuseMap;
#endif

#ifdef OOSTD_SPECULAR_MAP
uniform sampler2D		uSpecularMap;
#endif

#ifdef OOSTD_EMISSION_MAP
uniform sampler2D		uEmissionMap;
#endif

#ifdef OOSTD_ILLUMINATION_MAP
uniform sampler2D		uIlluminationMap;
#endif


#if OOSTD_DIFFUSE_MAP || OOSTD_SPECULAR_MAP || OOSTD_EMISSION_MAP || OOSTD_ILLUMINATION_MAP
#define NEED_TEX_COORD
#endif

#if OOSTD_EMISSION_AND_ILLUMINATION_MAP || OOSTD_ILLUMINATION_MAP
#define HAVE_ILLUMINATION
#endif


// Lambertian diffuse lighting model
#define DIFFUSE_LIGHT(idx) \
	{ \
		vec3 lightVector = normalize(gl_LightSource[idx].position.xyz); \
		float intensity = max(dot(normal, lightVector), 0.0); \
		diffuseLight += gl_LightSource[idx].diffuse * intensity; \
	}



#if OOSTD_SPECULAR
#define SPECULAR_LIGHT(idx) \
	{ \
		vec3 lightVector = normalize(gl_LightSource[idx].position.xyz); \
		vec3 reflection = normalize(-reflect(lightVector, normal)); \
		float intensity = pow(max(dot(reflection, eyeVector), 0.0), exponent); \
		specularLight += gl_LightSource[idx].specular * intensity; \
	}
#endif

#if OOSTD_SPECULAR
#define NEED_EYE_VECTOR
#endif

#if OOSTD_SPECULAR && OO_LIGHT_0_FIX
#define SPECULAR_LIGHT_0 SPECULAR_LIGHT(0)
#else
#define SPECULAR_LIGHT_0
#endif


void main(void)
{
	vec4 totalColor = vec4(0);
	vec3 normal = normalize(vNormal);
#ifdef NEED_EYE_VECTOR
	vec3 eyeVector = normalize(vEyeVector);
#endif
#ifdef NEED_TEX_COORD
	vec2 texCoord = gl_TexCoord[0].st;
#endif
	
	vec4 ambientLight = gl_FrontMaterial.ambient * gl_LightModel.ambient;
	
#if OOSTD_EMISSION || OOSTD_EMISSION_MAP
	vec4 emissionColor = vec4(1.0);
#endif
#if OOSTD_EMISSION
	emissionColor *= gl_FrontMaterial.emission;
#endif
#if OOSTD_EMISSION_MAP
	vec4 emissionMapColor = texture2D(uEmissionMap, texCoord);
	emissionColor *= emissionMapColor;
#endif
#if OOSTD_EMISSION || OOSTD_EMISSION_MAP
	emissionColor.a = 1.0;
	totalColor += emissionColor;
#endif
#if OOSTD_EMISSION_AND_ILLUMINATION_MAP
	// Use alpha channel of emission map as white illumination
	vec4 illuminationMapLight = vec4(emissionMapColor.aaa, 1.0);
#elif OOSTD_ILLUMINATION_MAP
	vec4 illuminationMapLight = texture2D(uIlluminationMap, texCoord);
#endif
	
	vec4 diffuseLight = vec4(0);
#if OO_LIGHT_0_FIX
	DIFFUSE_LIGHT(0)
#endif
	DIFFUSE_LIGHT(1)
	
#ifdef HAVE_ILLUMINATION
	diffuseLight += illuminationMapLight;
#endif
	
#if OOSTD_SPECULAR_MAP
	vec4 specularMapColor = texture2D(uSpecularMap, texCoord);
	float specularExponentLevel = pow(specularMapColor.a, 2.0) + 0.001;
	specularMapColor.a = 1.0;
	#define APPLY_MAPPED_EXPONENT exponent = (exponent - 1.0) * specularExponentLevel + 1.0;
#else
	#define APPLY_MAPPED_EXPONENT
#endif
#if OOSTD_SPECULAR
	vec4 specularLight = vec4(0);
	float exponent = gl_FrontMaterial.shininess;
	APPLY_MAPPED_EXPONENT
	SPECULAR_LIGHT_0
	SPECULAR_LIGHT(1)
	specularLight.a = 1.0;
#endif
	
	vec4 ambientColor = gl_FrontMaterial.ambient;
	vec4 diffuseColor = gl_FrontMaterial.diffuse;
#if OOSTD_SPECULAR
	vec4 specularColor = gl_FrontMaterial.specular;
#endif
#if OOSTD_SPECULAR_MAP
	specularColor *= specularMapColor;
#endif
	
#if OOSTD_DIFFUSE_MAP
	vec4 diffuseMapColor = texture2D(uDiffuseMap, texCoord);
	diffuseMapColor.a = 1.0;
	diffuseColor *= diffuseMapColor;
	ambientColor *= diffuseMapColor;
#endif
	
	totalColor += ambientColor * ambientLight + diffuseColor * diffuseLight;
#if OOSTD_SPECULAR
	totalColor += specularColor * specularLight;
#endif
	
	gl_FragColor = totalColor;
}
